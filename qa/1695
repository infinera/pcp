#!/bin/sh
# PCP QA Test No. 1695
# Valgrind pmproxy REST API test cases.

# Copyright (c) 2019 Red Hat.
#

seq=`basename $0`
echo "QA output created by $seq"

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check

_check_valgrind

_cleanup()
{
    cd $here
    [ -n "$redisport" ] && redis-cli -p $redisport shutdown
    $sudo rm -rf $tmp $tmp.*
}

status=1	# failure is the default!
username=`id -u -n`
$sudo rm -rf $tmp $tmp.* $seq.full
trap "_cleanup; exit \$status" 0 1 2 3 15

# create a pmproxy configuration
cat <<EOF > $tmp.conf
[pmproxy]
pcp.enabled = true
http.enabled = true
redis.enabled = false
[discover]
enabled = false
[pmsearch]
enabled = false
[pmseries]
enabled = false
EOF

_filter_port()
{
    sed \
	-e "s/ FD $port / FD PORT /g" \
	-e '/PORT ipv6 /d' \
    # end
}

# real QA test starts here

redisport=`_find_free_port`
echo "Start test Redis server ..."
redis-server --port $redisport > $tmp.redis 2>&1 &
echo "PING"
pmsleep 0.125
redis-cli -p $redisport ping
_check_redis_server_version $redisport

# start pmproxy
port=`_find_free_port`
mkdir -p $tmp.pmproxy/pmproxy
export PCP_RUN_DIR=$tmp.pmproxy
export PCP_TMP_DIR=$tmp.pmproxy

$_valgrind_clean_assert pmproxy -f -r $redisport -p $port -U $username -l- -c $tmp.conf >$tmp.valout 2>$tmp.valerr &
pid=$!

echo "valgrind pid: $pid" >>$seq.full
echo "pmproxy port: $port" >>$seq.full

# valgrind takes awhile to fire up
i=0
while [ $i -lt 40 ]
do
    $PCP_BINADM_DIR/telnet-probe -c localhost $port && break
    sleep 1
    i=`expr $i + 1`
done
if $PCP_BINADM_DIR/telnet-probe -c localhost $port
then
    echo "Startup took $i secs" >>$seq.full
else
    echo "Arrgh: valgrind failed start pmproxy and get port $port ready after 30 secs"
    exit
fi

params="polltimeout=20"

if which fuser >/dev/null
then
    echo "fuser for port $port ..." >>$seq.full
    $sudo fuser -n tcp $port >>$seq.full 2>&1
fi

if which pstree >/dev/null
then
    echo "pstree for pid $pid" >>$seq.full
    $sudo pstree -p $pid >>$seq.full 2>&1
fi

date >>$seq.full
echo "=== checking metric scrape operation ===" | tee -a $seq.full
curl -Gs "http://localhost:$port/metrics?$params" >$tmp.tmp 2>&1
grep "^curl" $tmp.tmp
cat $tmp.tmp >>$seq.full

date >>$seq.full
echo "=== checking short-fuse scrape operation ===" | tee -a $seq.full
curl -Gs "http://localhost:$port/metrics?polltimeout=1" >$tmp.tmp 2>&1
grep "^curl" $tmp.tmp
cat $tmp.tmp >>$seq.full

date >>$seq.full
echo "=== checking repeated scrape operation ===" | tee -a $seq.full
for f in `seq 1 100`; do
    curl -Gs "http://localhost:$port/metrics?names=kernel.all.load" >$tmp.tmp 2>&1
done
grep "^curl" $tmp.tmp
cat $tmp.tmp >>$seq.full

date >>$seq.full
echo "=== checking one client making multiple requests ===" | tee -a $seq.full
context="http://localhost:$port/pmapi/context"
curl -Gs $context $context >$tmp.tmp 2>&1
grep "^curl" $tmp.tmp
cat $tmp.tmp >>$seq.full

date >>$seq.full
echo "=== checking metric fetch operation ===" | tee -a $seq.full
metrics="sample.colour,sample.long.one,sample.long.one,sample.double.one"
curl -Gs "http://localhost:$port/pmapi/fetch?names=$metrics&$params" >$tmp.tmp 2>&1
grep "^curl" $tmp.tmp
cat $tmp.tmp >>$seq.full

date >>$seq.full
echo "=== checking url escaping operation ===" | tee -a $seq.full
metrics="%2Csample.long.one%2Csample.double.one%2C%2C"	# %2C == ','
curl -Gs "http://localhost:$port/pmapi/fetch?names=$metrics&$params" >$tmp.tmp 2>&1
grep "^curl" $tmp.tmp
cat $tmp.tmp >>$seq.full

echo "=== check pmproxy is running ==="
pminfo -v -h localhost@localhost:$port hinv.ncpu
if [ $? -eq 0 ]; then
    echo "pmproxy check passed"
else
    echo "pmproxy check failed"
fi

# valgrind takes awhile to shutdown too
pmsignal $pid
pmsleep 3.5
echo "=== valgrind stdout ===" | tee -a $seq.full
cat $tmp.valout | _filter_valgrind

echo "=== valgrind stderr ===" | tee -a $seq.full
cat $tmp.valerr | _filter_pmproxy_log | _filter_port

# success, all done
status=0
exit
